# ğŸ’¡Approach

### edge cases

- exactly the substring (xyz, xyz)
- having duplicates (xyz, xxyz â†’ â€œâ€)

### brainstorm

- Bruteforce
    - finding all combinations of the substring to find the one that includes all the characters in the given substring.

### time complexity

$O(n)$

- where $n$ is the number of chars in string 1

### space complexity

$O(m)$

- where $m$ is the number of unique chars in string 1

# ğŸ’¡Â Problem Analysis

### summary

- given a 2 strings, return the minimum length substring of the first string that includes all the chars from the second string.

### code

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == "": 
            return ""

        countT, window = {}, {}

        for c in t:
            countT[c] = 1 + countT.get(c, 0)
        
        have, need = 0, len(countT)
        res, resLen = [-1, -1], float("infinity")

        l = 0

        for r in range(len(s)):
            c = s[r]
            window[c] = 1 + window.get(c, 0)

            if c in countT and window[c] == countT[c]:
                have += 1
            
            while have == need:
                # update result
                if (r - l + 1) < resLen:
                    res = [l, r]
                    resLen = (r - l + 1)

                # pop from the left of window (since the have == need)
                window[s[l]] -= 1

                if s[l] in countT and window[s[l]] < countT[s[l]]:
                    have -=1

                l += 1
            
        l, r = res
        return s[l : r + 1] if resLen != float("infinity") else ""
                

```

### cause of failure

- tried doing it with moving 2 pointers and moving the right ptr back to where left pointer was but this made the time complexity go up â†’ timed out

### take aways & key points

- repeating $O(1)$ operations are good!

# ğŸ’¡Â One Line Summary

<aside>
ğŸ“Œ

create 2 hashmaps: window, t (acc string, substring) â†’ init t hasmap with the chars needed and the count â†’ count the number of â€œcompleted charsâ€ â†’ this basically counts how many chars met the requirements (if there are 2 As and 4 Bs, the count is 2 : A and B) â†’ move the right pointer to the right until the requirement numbers are EQUAL â†’ iff the number of chars for both window and t are equal update the â€œhaveâ€ count â†’ if have count is equal to the need, move the left pointer until its not equal again so we can find new combination â†’ store the index and length, only update if length is the minimum â†’ keep on moving to the right if the have is not equal to the need

</aside>
